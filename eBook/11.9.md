# 11.9 空接口

## 11.9.1 概念

**空接口或者最小接口** 不包含任何方法，它对实现不做任何要求：

```go
type Any interface {}
```

任何其他类型都实现了空接口（它不仅仅像 `Java/C#` 中 `Object` 引用类型），`any` 或 `Any` 是空接口一个很好的别名或缩写。

空接口类似 `Java/C#` 中所有类的基类： `Object` 类，二者的目标也很相近。

可以给一个空接口类型的变量 `var val interface {}` 赋任何类型的值。

示例 11.8 [empty_interface.go](examples/chapter_11/empty_interface.go)：

```go
package main
import "fmt"

var i = 5
var str = "ABC"

type Person struct {
	name string
	age  int
}

type Any interface{}

func main() {
	var val Any
	val = 5
	fmt.Printf("val has the value: %v\n", val)
	val = str
	fmt.Printf("val has the value: %v\n", val)
	pers1 := new(Person)
	pers1.name = "Rob Pike"
	pers1.age = 55
	val = pers1
	fmt.Printf("val has the value: %v\n", val)
	switch t := val.(type) {
	case int:
		fmt.Printf("Type int %T\n", t)
	case string:
		fmt.Printf("Type string %T\n", t)
	case bool:
		fmt.Printf("Type boolean %T\n", t)
	case *Person:
		fmt.Printf("Type pointer to Person %T\n", t)
	default:
		fmt.Printf("Unexpected type %T", t)
	}
}
```

输出：

    val has the value: 5
    val has the value: ABC
    val has the value: &{Rob Pike 55}
    Type pointer to Person *main.Person

在上面的例子中，接口变量 `val` 被依次赋予一个 `int`，`string` 和 `Person` 实例的值，然后使用 `type-switch` 来测试它的实际类型。每个 `interface {}` 变量在内存中占据两个字长：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针。

示例 [emptyint_switch.go](examples/chapter_11/emptyint_switch.go) 说明了空接口在 `type-switch` 中联合 `lambda` 函数的用法：

```go
package main

import "fmt"

type specialString string

var whatIsThis specialString = "hello"

func TypeSwitch() {
	testFunc := func(any interface{}) {
		switch v := any.(type) {
		case bool:
			fmt.Printf("any %v is a bool type", v)
		case int:
			fmt.Printf("any %v is an int type", v)
		case float32:
			fmt.Printf("any %v is a float32 type", v)
		case string:
			fmt.Printf("any %v is a string type", v)
		case specialString:
			fmt.Printf("any %v is a special String!", v)
		default:
			fmt.Println("unknown type!")
		}
	}
	testFunc(whatIsThis)
}

func main() {
	TypeSwitch()
}
```

输出：

    any hello is a special String!

**练习 11.9** [simple_interface3.go](exercises\chapter_11\simple_interface3.go)：

继续练习 11.2，在它中添加一个 `gI()` 函数，它不再接受 `Simpler` 类型的参数，而是接受一个空接口参数。然后通过类型断言判断参数是否是 `Simpler` 类型。最后在 `main` 使用 `gI()` 取代 `fI()` 函数并调用它。确保你的代码足够安全。

## 11.9.2 构建通用类型或包含不同类型变量的数组

在 [7.6.6](07.6.md) 中我们看到了能被搜索和排序的 `int` 数组、`float` 数组以及 `string` 数组，那么对于其他类型的数组呢，是不是我们必须得自己编程实现它们？、

这里先举一个简单的例子：
```
type rectangle struct {  
   height float64  
   width float64  
}  
type Any interface{}  
func main() {  
   var a = new([3]Any)  
   a[0] = "Hello,World"  
   a[1] = 32  
   a[2] = &rectangle{3,4}  
   for _,b := range a {  
      fmt.Printf("%v\t%[1]T\n",b)  
   }  
}
```
其中 变量a 存储三个空接口(Any)，在对每个空接口进行赋值，并进行输出，即可实现同一个数组包含不同数据类型。其输出结果如下：
```
Hello,World	string
32	int
&{3 4}	*main.rectangle
```
此外我们可以定义一个容器类型的结构体来包含空接口(Any)类型的元素切片。
```
type Container struct{
   a []Any
}
```
其中Container里面可以存放任何类型的变量，因为空接口可以赋予任何类型的值。
我们可以定义一个方法 At 用于返回第 i 个元素的值，同时我们也可以定义一个方法 Set 用于设置第 i 个元素的值。如下：
```
func (p *Container) Set(i int, e Any){  
p.a[i] = e  
}  
func (p *Container) At(i int) Any{  
return p.a[i]  
}
```
因此我们可以切片来对原数组进行修改。对之间的简例进行修改得到的完整的函数如下：
```
type rectangle struct {  
height float64  
width float64  
}  
type Any interface{}  
type Container struct{  
a []Any  
}  
func (p *Container) Set(i int, e Any){  
p.a[i] = e  
}  
func (p *Container) At(i int) Any{  
return p.a[i]  
}
func main() {  
var a = new([3]Any)  
b := Container{a[:]}  
a[0] = "Hello,World"  
a[1] = 32  
a[2] = &rectangle{3,4}  
b.Set(0,"Hello")  
b.Set(1,123.4)  
for c := range a {  
fmt.Printf("%v\t%[1]T\n",b.At(c))  
}  
}
```
其输出结果如下：
```
Hello	string
123.4	float64
&{3 4}	*main.rectangle
```
通过结果的对比可得已实现At、Set方法，即不仅可以修改数据的值，同时也可以修改数据的类型。

`Container` 中存储的所有元素都是 `Any` 类型，要得到它们的原始类型（unboxing：拆箱）需要用到类型断言。TODO：The compiler rejects assertions guaranteed to fail，类型断言总是在运行时才执行，因此它会产生运行时错误。

**练习 11.10** [min_interface.go](exercises\chapter_11\min_interface.go) / [minmain.go](exercises\chapter_11\minmain.go)：

仿照 11.7 中开发的 `Sorter` 接口，创建一个 `Miner` 接口并实现一些必要的操作。函数 `Min()` 接受一个 `Miner` 类型变量的集合，然后计算并返回集合中最小的元素。

## 11.9.3 复制数据切片至空接口切片

假设你有一个 `myType` 类型的数据切片，你想将切片中的数据复制到一个空接口切片中，类似：

```go
var dataSlice []myType = FuncReturnSlice()
var interfaceSlice []interface{} = dataSlice
```

可惜不能这么做，编译时会出错：`cannot use dataSlice (type []myType) as type []interface { } in assignment`。

原因是它们俩在内存中的布局是不一样的（参考 [Go wiki](https://github.com/golang/go/wiki/InterfaceSlice)）。

必须使用 `for-range` 语句来一个一个显式地赋值：

```go
var dataSlice []myType = FuncReturnSlice()
var interfaceSlice []interface{} = make([]interface{}, len(dataSlice))
for i, d := range dataSlice {
    interfaceSlice[i] = d
}
```

## 11.9.4 通用类型的节点数据结构

在 [10.1](10.1.md) 中我们遇到了诸如列表和树这样的数据结构，在它们的定义中使用了一种叫节点的递归结构体类型，节点包含一个某种类型的数据字段。现在可以使用空接口作为数据字段的类型，这样我们就能写出通用的代码。下面是实现一个二叉树的部分代码：通用定义、用于创建空节点的 `NewNode` 方法，及设置数据的 `SetData` 方法。

示例 11.10 [node_structures.go](examples/chapter_11/node_structures.go)：

```go
package main

import "fmt"

type Node struct {
	le   *Node
	data interface{}
	ri   *Node
}

func NewNode(left, right *Node) *Node {
	return &Node{left, nil, right}
}

func (n *Node) SetData(data interface{}) {
	n.data = data
}

func main() {
	root := NewNode(nil, nil)
	root.SetData("root node")
	// make child (leaf) nodes:
	a := NewNode(nil, nil)
	a.SetData("left node")
	b := NewNode(nil, nil)
	b.SetData("right node")
	root.le = a
	root.ri = b
	fmt.Printf("%v\n", root) // Output: &{0x125275f0 root node 0x125275e0}
}
```

## 11.9.5 接口到接口

一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法。这个转换是在运行时进行检查的，转换失败会导致一个运行时错误：这是 `Go` 语言动态的一面，可以拿它和 `Ruby` 和 `Python` 这些动态语言相比较。

假定：

```go
var ai AbsInterface // declares method Abs()
type SqrInterface interface {
    Sqr() float
}
var si SqrInterface
pp := new(Point) // say *Point implements Abs, Sqr
var empty interface{}
```

那么下面的语句和类型断言是合法的：

```go
empty = pp                // everything satisfies empty
ai = empty.(AbsInterface) // underlying value pp implements Abs()
// (runtime failure otherwise)
si = ai.(SqrInterface) // *Point has Sqr() even though AbsInterface doesn’t
empty = si             // *Point implements empty set
// Note: statically checkable so type assertion not necessary.
```

下面是函数调用的一个例子：

```go
type myPrintInterface interface {
	print()
}

func f3(x myInterface) {
	x.(myPrintInterface).print() // type assertion to myPrintInterface
}
```

`x` 转换为 `myPrintInterface` 类型是完全动态的：只要 `x` 的底层类型（动态类型）定义了 `print` 方法这个调用就可以正常运行（译注：若 `x` 的底层类型未定义 `print` 方法，此处类型断言会导致 `panic`，最佳实践应该为 `if mpi, ok := x.(myPrintInterface); ok { mpi.print() }`，参考 [11.3](11.3.md) 章节）。

### 将接口赋值给接口

在Go语言中，只要两个接口拥有相同的方法列表(与顺序无关)，那么他们就是等同的，可以相互赋值。不过，这里有一个前提，那就是接口变量持有的是基于对应实现类的实例值，所以接口与接口间的赋值是基于类实例与接口间的赋值的。

#### 完全对等
下面我们来编写对应的示例代码，这是第一个接口 Number1：
```
type Number1 interface {
Equal(i int) bool
LessThan(i int) bool
MoreThan(i int) bool
}
```
这是第二个接口 Number2：
```
type Number2 interface {
Equal(i int) bool
MoreThan(i int) bool
LessThan(i int) bool
}
```
这里我们定义了两个接口，一个叫 Number1，一个叫 Number2，两者都定义三个相同的方法，只是顺序不同而已。在 Go 语言中，这两个接口实际上并无区别，因为：

1.任何实现了 Number1 接口的类，也实现了 Number2；

2.任何实现了 Number1 接口的类实例都可以赋值给 Number2，反之亦然；

3.在任何地方使用 Number1 接口与使用 Number2 并无差异。

接下来我们定义一个实现了这两个接口的类 Number：
```
type Number int

func (n Number) Equal(i int) bool {
return int(n) == i
}

func (n Number) LessThan(i int) bool {
return int(n) &lt; i
}

func (n Number) MoreThan(i int) bool {
return int(n) > i
}
```
那么下面这些赋值代码都是合法的，会编译通过：
```
var num1 Number = 1
var num2 Number1 = num1
var num3 Number2 = num2
```
#### 方法子集
此外，接口赋值并不要求两个接口完全等价（方法完全相同）。如果接口 A 的方法列表是接口 B 的方法列表的子集，那么接口 B 也可以赋值给接口 A。例如，假设 Number2 接口定义如下：
```
type Number2 interface {
Equal(i int) bool
MoreThan(i int) bool
LessThan(i int) bool
Add(i int)
}
```
要让 Number 类继续保持实现这两个接口，需要在 Number 类定义中新增一个 Add 方法实现（这里定义了一个指针方法）：
```
func (n *Number) Add(i int) {
*n = *n + Number(i)
}
```
接下来，将上面的接口赋值语句改写如下即可：
```
var num1 Number = 1
var num2 Number2 = &num1
var num3 Number1 = num2
```
这样一来，就实现了接口赋值，但是反过来不行：
```
var num1 Number = 1
var num2 Number1 = &num1
var num3 Number2 = num2 // 这一段编译出错
```
因为 Number1 接口中没有声明 Add 方法，或者换句话说，实现了 Number2 接口的类肯定实现了 Number1，但是实现了 Number1 接口的类不一定实现了 Number2。

（```var num2 Number2 = &num1```和```var num2 Number1 = &num1```原因参考11.6 [使用方法集与接口](11.6.md)）
- **指针方法可以通过指针调用**
- **值方法可以通过值调用**
- **接收者是值的方法可以通过指针调用，因为指针会首先被解引用**
- **接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址**


## 链接

- [目录](directory.md)
- 上一节：[第二个例子：读和写](11.8.md)
- 下一节：[反射包](11.10.md)
