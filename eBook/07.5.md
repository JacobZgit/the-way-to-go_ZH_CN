# 7.5 切片的复制与追加

原文这段写的太差劲，已经替换为自己总结的内容。

这一部分强烈推荐看我自己买的书《Go语言实战》-4.2.3 使用切片 作为补充（写的贼好，特别清晰易懂）

预备

切片是对其底层数组的某一段的引用。

切片有 len 和 cap 两个属性，代表切片的引用长度和切片的容量（从切片的引用起点位置到其底层数组最末端的长度。因为其底层数组的长度是固定的，这也就是意味着容量是指切片可引用的最大宽度）。

### append 函数
```go
slice2 := append(slice1, 23, 15)
```
以上对切片 slice1 进行 append 操作。该操作遵循以下原则：

append 函数对一个切片 slice1 进行追加操作，并返回另一个长度为 len(slice1) + 追加个数 的切片，原切片不被改动，两个切片所指向的底层数组可能是同一个也可能不是，取决于第二条：
slice1 是对其底层数组的一段引用，若 append 追加完之后没有突破 slice1 的容量，则实际上追加的数据改变了其底层数组对应的值，并且 append 函数返回对底层数组新的引用（切片）；若 append 追加的数据量突破了 slice1 的最大容量（底层数组长度固定，无法增加长度赋予新值），则 Go 会在内存中申请新的数组（数组内的值为追加操作之后的值），并返回对新数组的引用（切片）。
示例：
```go
// 声明并初始化长度为 5 的整型数组 [0 0 0 0 0]
var arr [5]int

// slice1 和 slice2 是对 arr 第 2 个元素到第 4 个元素的引用
slice1 := arr[1:4] // slice1: [0 0 0]
slice2 := arr[1:4] // slice2: [0 0 0]

// 对切片的修改会反映到底层数组
slice1[0] = 1 // slice1:[1 0 0] slice2:[1 0 0] arr:[0 1 0 0 0]
// 对底层数组的修改同样会反映到指向它的切片
arr[2] = 2 // slice1:[1 2 0] slice2:[1 2 0] arr:[0 1 2 0 0]

// 因为对 slice1 的追加没有突破其底层数组的长度，所以返回的切片还是指向原来的底层数组
slice3 := append(slice1, 4) // slice1:[1 2 0] slice2:[1 2 0] slice3:[1 2 0 4] arr:[0 1 2 0 4]
slice3[2] = 3 // slice1:[1 2 3] slice2:[1 2 3] slice3:[1 2 3 4] arr:[0 1 2 3 4]

// 如果对切片的追加突破了底层数组的长度，则会分配一个新的数组，返回指向新数组的切片
slice3 = append(slice3, 5) // slice1:[1 2 3] slice2:[1 2 3] slice3:[1 2 3 4 5] arr:[0 1 2 3 4]
// slice3 的底层数组已经改变，对它的操作不会影响到 slice1 slice2 和 arr
slice3[0] = 6 // slice1:[1 2 3] slice2:[1 2 3] slice3:[6 2 3 4 5] arr:[0 1 2 3 4]
```
惯用方式
```go
slice1 = append(slice1, 5, 6)
```
因为 append 操作的切片变量的类型和返回的切片的类型相同，所以一般将返回值再赋予给原变量。这样被操作的切片变量在操作之后：

变为对原底层数组新的一段长度的引用，或：
变为对新数组的引用，原底层数组若无其他地方引用，内存将会被回收。

### copy() 拷贝 (深拷贝)

如果要切片深拷贝，需要用到copy()内置函数,拷贝的是切片中的值。
```go
所谓深浅拷贝，其实都是进行复制，主要区别在于复制出来的新对象和原来的对象，它们的数据发生改变时，是否会相互影响。

简单而言，B 复制 A，如果 A 的数据发生变化，B 也跟着变化，这是浅拷贝。

反之， 如果 B 不发生变化，则为深拷贝。

深浅拷贝差异的根本原因在于，复制出来的对象与原对象是否会指向同一个地址。
```
```
	a := []int{1, 2, 3, 4}
	b := []int{-1, -2, -3, -4}
	copy(b, a)
	b[3] = 777   //a不会随b的变化而变化
	fmt.Println(a, b) //[1 2 3 4] [1 2 3 777]
```
```
	a := []int{1, 2, 3, 4}
	b := a[:]
	copy(b, a)
	b[3] = 777  //a随b变化而变化了，其实是因为切片a和b指向同一个底层数组，实际上也是拷贝的切片中的值
	fmt.Println(a, b) //[1 2 3 777] [1 2 3 777]
```
![](C:\Users\86185\Desktop\3c1105db89a95ef572210f41ddb10955.png)

### 判断深浅拷贝总结：

其实就是记住一个原则：Go语言实际上全部是值传递，这是因为Go语言定义的每个变量都占用一个唯一的内存位置,因此go语言不能创建两个共享同一内存位置的变量。

而变量赋值或者函数传参等等这些拷贝行为都遵循着这一原则，但为什么有的就是深拷贝，有的就是浅拷贝呢？

其实就是有的变量是值类型（变量直接存储值），有的变量是引用类型（变量存储的值是一个内存地址）

对于引用类型来说，其实也是值传递，但是是内存地址被当成了值进行传递，就可能造成了浅拷贝的发生。

例子：
```
	slice1 := []int{10, 20, 30, 40, 50} //slice-引用类型
	slice2 := slice1 //浅拷贝
	slice2[0] = 0
	fmt.Println(slice1, slice2) //[0 20 30 40 50] [0 20 30 40 50]

	arr1 := [5]int{10, 20, 30, 40, 50} //数组-值类型
	arr2 := arr1 //深拷贝
	arr2[0] = 0
	fmt.Println(arr1, arr2) //[10 20 30 40 50] [0 20 30 40 50]
```
- [目录](directory.md)
- 上一节：[切片重组 (reslice)](07.4.md)
- 下一节：[字符串、数组和切片的应用](07.6.md)
